\chapter{Coding \glc}

\section{Optimization}\label{sec:Optimization}\index{optimization}

In designing \glc, we opted for simplicity and clarity over speed. However, there are numerous parts of the code where optimization has been performed without a significant loss of clarity. In this section we discuss some of the techniques used.

\subsection{Unique IDs and Stored Properties}\index{unique ID}

Frequently, a given property of a node may be required in many different aspects of the calculation. For example, the dark matter halo virial radius is used extensively in several distinct calculations within \glc. Frequently such calculations are performed for the same node, with the same properties several times\footnote{For example, \glc's ODE solver will fix the properties of a node and then request that derivatives of all properties be computed. Some functions will then be called multiple times for the same node with unchanged properties.}. Obviously this is inefficient. It can be advantageous in such cases to store the result of a calculation and, if the function is called again with the same unchanged node to simply return the stored value. \glc\ facilitates this by two features.

The first feature is the ``unique ID''---an integer number assigned to each node in \glc\ and which uniquely identifies a node (i.e. no two nodes processed in a \glc\ run will have the same unique ID). This number, which can be retrieved using the \href{method:uniqueID}{{\tt uniqueID}} property of a tree node, can be recorded each time a function is called. If called again for a node with the same unique ID as the previous call, the function can simply return the same answer as on the previous call.

The second feature accounts for the fact that the properties of a node will change, so even if a function is called on a node with the same unique ID it may occasionally need to recompute its result. \glc\ provides a calculation reset task\index{calculation reset task}\index{task, calculation reset} (see \S\ref{CalculationResetTask}). All such tasks are performed just prior to the computation of derivatives for a node being evolved. A function can register a calculation reset task and use it to flag that it must update its calculations even if called again with the same node.

\section{Objects}

\subsection{Object Methods}

\input{dataMethods}

