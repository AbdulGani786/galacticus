!! Copyright 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018,
!!           2019
!!    Andrew Benson <abenson@carnegiescience.edu>
!!
!! This file is part of Galacticus.
!!
!!    Galacticus is free software: you can redistribute it and/or modify
!!    it under the terms of the GNU General Public License as published by
!!    the Free Software Foundation, either version 3 of the License, or
!!    (at your option) any later version.
!!
!!    Galacticus is distributed in the hope that it will be useful,
!!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!!    GNU General Public License for more details.
!!
!!    You should have received a copy of the GNU General Public License
!!    along with Galacticus.  If not, see <http://www.gnu.org/licenses/>.

  use :: Atomic_Cross_Sections_Ionization_Photo      , only : atomicCrossSectionIonizationPhotoClass
  use :: Atomic_Ionization_Potentials                , only : atomicIonizationPotentialClass
  use :: Atomic_Radiation_Gaunt_Factors              , only : gauntFactorClass
  use :: Atomic_Rates_Excitation_Collisional         , only : atomicExcitationRateCollisionalClass
  use :: Atomic_Rates_Ionization_Collisional         , only : atomicIonizationRateCollisionalClass
  use :: Atomic_Rates_Recombination_Dielectronic     , only : atomicRecombinationRateDielectronicClass
  use :: Atomic_Rates_Recombination_Radiative        , only : atomicRecombinationRateRadiativeClass
  use :: Atomic_Rates_Recombination_Radiative_Cooling, only : atomicRecombinationRateRadiativeCoolingClass
  use :: Mass_Distributions                          , only : massDistributionClass
  
  !# <radiativeTransferMatter name="radiativeTransferMatterAtomic">
  !#  <description>A task which performs radiative transfer.</description>
  !# </radiativeTransferMatter>
  type, extends(radiativeTransferMatterClass) :: radiativeTransferMatterAtomic
     !% Implementation of a radiative transfer matter class for atomic matter.
     private
     class           (massDistributionClass                       ), pointer                   :: massDistribution_                        => null()
     class           (atomicCrossSectionIonizationPhotoClass      ), pointer                   :: atomicCrossSectionIonizationPhoto_       => null()
     class           (atomicRecombinationRateRadiativeClass       ), pointer                   :: atomicRecombinationRateRadiative_        => null()
     class           (atomicRecombinationRateRadiativeCoolingClass), pointer                   :: atomicRecombinationRateRadiativeCooling_ => null()
     class           (atomicIonizationRateCollisionalClass        ), pointer                   :: atomicIonizationRateCollisional_         => null()
     class           (atomicRecombinationRateDielectronicClass    ), pointer                   :: atomicRecombinationRateDielectronic_     => null()
     class           (atomicIonizationPotentialClass              ), pointer                   :: atomicIonizationPotential_               => null()
     class           (atomicExcitationRateCollisionalClass        ), pointer                   :: atomicExcitationRateCollisional_         => null()
     class           (gauntFactorClass                            ), pointer                   :: gauntFactor_                             => null()
     integer                                                                                   :: indexAbundancePattern                             , iterationAverageCount, &
          &                                                                                       countElements                                     , indexHydrogen
     integer         (c_size_t                                    )                            :: countOutputs_
     logical                                                                                   :: outputRates
     double precision                                                                          :: metallicity                                       , temperatureMinimum
     double precision                                              , allocatable, dimension(:) :: numberDensityMassDensityRatio                     , elementAtomicMasses
     type            (varying_string                              )                            :: abundancePattern
     character       (len=2                                       ), allocatable, dimension(:) :: elements
     integer                                                       , allocatable, dimension(:) :: elementAtomicNumbers
   contains
     !@ <objectMethods>
     !@   <object>radiativeTransferMatterAtomic</object>
     !@   <objectMethod>
     !@     <method>recombinationRateHydrogen</method>
     !@     <type>\doublezero</type>
     !@     <arguments>\textcolor{red}{\textless type(radiativeTransferPropertiesMatterAtomic)\textgreater} properties</arguments>
     !@     <description>Return the total rate of recombinations (in units of s$^{-1}$).</description>
     !@   </objectMethod>
     !@ </objectMethods>
     final     ::                              atomicDestructor
     procedure :: propertyClass             => atomicPropertyClass
     procedure :: populateDomain            => atomicPopulateDomain
     procedure :: reset                     => atomicReset
     procedure :: absorptionCoefficient     => atomicAbsorptionCoefficient
     procedure :: accumulatePhotonPacket    => atomicAccumulatePhotonPacket
     procedure :: interactWithPhotonPacket  => atomicInteractWithPhotonPacket
     procedure :: stateSolve                => atomicStateSolve
     procedure :: convergenceMeasure        => atomicConvergenceMeasure
     procedure :: outputProperty            => atomicOutputProperty
     procedure :: countOutputs              => atomicCountOutputs
     procedure :: outputName                => atomicOutputName
     procedure :: recombinationRateHydrogen => atomicRecombinationRateHydrogen
#ifdef USEMPI
     procedure :: accumulationReduction    => atomicAccumulationReduction
     procedure :: broadcastDomain          => atomicBroadcastDomain
     procedure :: broadcastState           => atomicBroadcastState
#endif
  end type radiativeTransferMatterAtomic
  
  interface radiativeTransferMatterAtomic
     !% Constructors for the {\normalfont \ttfamily atomic} radiative transfer matter class.
     module procedure atomicConstructorParameters
     module procedure atomicConstructorInternal
  end interface radiativeTransferMatterAtomic

  type, public :: element
     !% Type used to store elemental states.
     double precision                              :: densityNumber
     double precision, dimension(:,:), allocatable :: photoIonizationRateHistory , photoHeatingRateHistory
     double precision, dimension(:  ), allocatable :: photoIonizationRate        , photoHeatingRate        , &
          &                                           photoIonizationRatePrevious, photoHeatingRatePrevious, &
          &                                           ionizationStateFraction
  end type element
  
  type, extends(radiativeTransferPropertiesMatter), public :: radiativeTransferPropertiesMatterAtomic
     !% Radiative transfer matter properties class for atomic matter.
     integer                                              :: iterationCount
     double precision                                     :: volume        , temperature
     type            (element), dimension(:), allocatable :: elements
  end type radiativeTransferPropertiesMatterAtomic

  ! Module-scope objects needed for solving for thermal equilibrium.
  class           (radiativeTransferMatterAtomic          )                , pointer     :: atomicSelf
  type            (element                                ), dimension( : ), allocatable :: atomicElementsPhotoRate
  type            (radiativeTransferPropertiesMatterAtomic)                , pointer     :: atomicProperties
  double precision                                                                       :: atomicDensityNumberElectrons
  integer                                                                                :: atomicRecombinationCase
  !$omp threadprivate(atomicSelf,atomicElementsPhotoRate,atomicProperties,atomicDensityNumberElectrons,atomicRecombinationCase)

  ! Tolerance parameters.
  double precision                                         , parameter                   :: atomicIonizationStateFractionToleranceAbsolute=1.0d-12, atomicIonizationStateFractionToleranceRelative=1.0d-2

contains

  function atomicConstructorParameters(parameters) result(self)
    !% Constructor for the {\normalfont \ttfamily atomic} radiative transfer matter class which takes a parameter set as input.
    use :: Input_Parameters                , only : inputParameters , inputParameter
    use :: Numerical_Constants_Astronomical, only : metallicitySolar
    implicit none
    type            (radiativeTransferMatterAtomic               )                             :: self
    type            (inputParameters                             ), intent(inout)              :: parameters
    class           (massDistributionClass                       ), pointer                    :: massDistribution_
    class           (atomicCrossSectionIonizationPhotoClass      ), pointer                    :: atomicCrossSectionIonizationPhoto_
    class           (atomicRecombinationRateRadiativeClass       ), pointer                    :: atomicRecombinationRateRadiative_
    class           (atomicRecombinationRateRadiativeCoolingClass), pointer                    :: atomicRecombinationRateRadiativeCooling_
    class           (atomicIonizationRateCollisionalClass        ), pointer                    :: atomicIonizationRateCollisional_
    class           (atomicRecombinationRateDielectronicClass    ), pointer                    :: atomicRecombinationRateDielectronic_
    class           (atomicIonizationPotentialClass              ), pointer                    :: atomicIonizationPotential_
    class           (atomicExcitationRateCollisionalClass        ), pointer                    :: atomicExcitationRateCollisional_
    class           (gauntFactorClass                            ), pointer                    :: gauntFactor_
    character       (len=2                                       ), dimension(:) , allocatable :: elements
    integer                                                                                    :: iterationAverageCount    
    double precision                                                                           :: temperatureMinimum                      , metallicity
    type            (varying_string                              )                             :: abundancePattern
    logical                                                                                    :: outputRates
    
    !# <inputParameter>
    !#   <name>iterationAverageCount</name>
    !#   <cardinality>1</cardinality>
    !#   <defaultValue>5</defaultValue>
    !#   <description>The number of iterations over which to average the photoionization rate.</description>
    !#   <source>parameters</source>
    !#   <type>real</type>
    !# </inputParameter>
    !# <inputParameter>
    !#   <name>temperatureMinimum</name>
    !#   <cardinality>1</cardinality>
    !#   <defaultValue>1.0d0</defaultValue>
    !#   <description>The minimum temperature that matter is allowed to reach in the case of zero photoheating.</description>
    !#   <source>parameters</source>
    !#   <type>real</type>
    !# </inputParameter>
    !# <inputParameter>
    !#   <name>abundancePattern</name>
    !#   <cardinality>1</cardinality>
    !#   <defaultValue>var_str('solar')</defaultValue>
    !#   <description>The abundance pattern to use.</description>
    !#   <source>parameters</source>
    !#   <type>string</type>
    !# </inputParameter>
    !# <inputParameter>
    !#   <name>metallicity</name>
    !#   <cardinality>1</cardinality>
    !#   <defaultValue>metallicitySolar</defaultValue>
    !#   <description>The metallicity to use.</description>
    !#   <source>parameters</source>
    !#   <type>real</type>
    !# </inputParameter>
    if (parameters%isPresent('elements')) then
       allocate(elements(parameters%count('elements')))
    else
       allocate(elements(1                           ))
    end if
    !# <inputParameter>
    !#   <name>elements</name>
    !#   <cardinality>1</cardinality>
    !#   <defaultValue>['H']</defaultValue>
    !#   <description>The elements to include.</description>
    !#   <source>parameters</source>
    !#   <type>string</type>
    !# </inputParameter>
    !# <inputParameter>
    !#   <name>outputRates</name>
    !#   <cardinality>1</cardinality>
    !#   <defaultValue>.false.</defaultValue>
    !#   <description>If true, output photoionization and heating rates.</description>
    !#   <source>parameters</source>
    !#   <type>boolean</type>
    !# </inputParameter>
    !# <objectBuilder class="massDistribution"                        name="massDistribution_"                        source="parameters"/>
    !# <objectBuilder class="atomicCrossSectionIonizationPhoto"       name="atomicCrossSectionIonizationPhoto_"       source="parameters"/>
    !# <objectBuilder class="atomicRecombinationRateRadiative"        name="atomicRecombinationRateRadiative_"        source="parameters"/>
    !# <objectBuilder class="atomicRecombinationRateRadiativeCooling" name="atomicRecombinationRateRadiativeCooling_" source="parameters"/>
    !# <objectBuilder class="atomicIonizationRateCollisional"         name="atomicIonizationRateCollisional_"         source="parameters"/>
    !# <objectBuilder class="atomicRecombinationRateDielectronic"     name="atomicRecombinationRateDielectronic_"     source="parameters"/>
    !# <objectBuilder class="atomicIonizationPotential"               name="atomicIonizationPotential_"               source="parameters"/>
    !# <objectBuilder class="atomicExcitationRateCollisional"         name="atomicExcitationRateCollisional_"         source="parameters"/>
    !# <objectBuilder class="gauntFactor"                             name="gauntFactor_"                             source="parameters"/>
    self=radiativeTransferMatterAtomic(abundancePattern,metallicity,elements,iterationAverageCount,temperatureMinimum,outputRates,massDistribution_,atomicCrossSectionIonizationPhoto_,atomicRecombinationRateRadiative_,atomicRecombinationRateRadiativeCooling_,atomicIonizationRateCollisional_,atomicRecombinationRateDielectronic_,atomicIonizationPotential_,atomicExcitationRateCollisional_,gauntFactor_)
    !# <objectDestructor name="massDistribution_"                       />
    !# <objectDestructor name="atomicCrossSectionIonizationPhoto_"      />
    !# <objectDestructor name="atomicRecombinationRateRadiative_"       />
    !# <objectDestructor name="atomicRecombinationRateRadiativeCooling_"/>
    !# <objectDestructor name="atomicIonizationRateCollisional_"        />
    !# <objectDestructor name="atomicRecombinationRateDielectronic_"    />
    !# <objectDestructor name="atomicIonizationPotential_"              />
    !# <objectDestructor name="atomicExcitationRateCollisional_"        />
    !# <objectDestructor name="gauntFactor_"                            />
    return
  end function atomicConstructorParameters

  function atomicConstructorInternal(abundancePattern,metallicity,elements,iterationAverageCount,temperatureMinimum,outputRates,massDistribution_,atomicCrossSectionIonizationPhoto_,atomicRecombinationRateRadiative_,atomicRecombinationRateRadiativeCooling_,atomicIonizationRateCollisional_,atomicRecombinationRateDielectronic_,atomicIonizationPotential_,atomicExcitationRateCollisional_,gauntFactor_) result(self)
    !% Internal constructor for the {\normalfont \ttfamily atomic} radiative transfer matter class.
    use :: Abundances_Structure            , only : abundances              , metallicityTypeLinearByMassSolar, adjustElementsReset, Abundances_Index_From_Name
    use :: Atomic_Data                     , only : Abundance_Pattern_Lookup, Atomic_Abundance                , Atomic_Mass        , Atomic_Number
    use :: ISO_Varying_String              , only : char
    use :: Numerical_Constants_Astronomical, only : massSolar               , megaParsec                      , metallicitySolar
    use :: Numerical_Constants_Atomic      , only : atomicMassUnit
    use :: Numerical_Constants_Prefixes    , only : centi
    use :: String_Handling                 , only : String_Count_Words      , String_Split_Words
    implicit none
    type            (radiativeTransferMatterAtomic               )                              :: self
    integer                                                       , intent(in   )               :: iterationAverageCount
    double precision                                              , intent(in   )               :: temperatureMinimum                      , metallicity
    type            (varying_string                              ), intent(in   )               :: abundancePattern
    logical                                                       , intent(in   )               :: outputRates
    character       (len=2                                       ), intent(in   ), dimension(:) :: elements
    class           (massDistributionClass                       ), intent(in   ), target       :: massDistribution_
    class           (atomicCrossSectionIonizationPhotoClass      ), intent(in   ), target       :: atomicCrossSectionIonizationPhoto_
    class           (atomicRecombinationRateRadiativeClass       ), intent(in   ), target       :: atomicRecombinationRateRadiative_
    class           (atomicRecombinationRateRadiativeCoolingClass), intent(in   ), target       :: atomicRecombinationRateRadiativeCooling_
    class           (atomicIonizationRateCollisionalClass        ), intent(in   ), target       :: atomicIonizationRateCollisional_
    class           (atomicRecombinationRateDielectronicClass    ), intent(in   ), target       :: atomicRecombinationRateDielectronic_
    class           (atomicIonizationPotentialClass              ), intent(in   ), target       :: atomicIonizationPotential_
    class           (atomicExcitationRateCollisionalClass        ), intent(in   ), target       :: atomicExcitationRateCollisional_
    class           (gauntFactorClass                            ), intent(in   ), target       :: gauntFactor_
    double precision                                              , allocatable  , dimension(:) :: abundancesRelative
    double precision                                                                            :: numberDensityMassDensityRatioHydrogen    , numberDensityMassDensityRatioHelium
    type            (abundances                                  )                              :: abundances_
    integer                                                                                     :: i
    !# <constructorAssign variables="abundancePattern, metallicity, elements, iterationAverageCount, temperatureMinimum, outputRates, *massDistribution_, *atomicCrossSectionIonizationPhoto_, *atomicRecombinationRateRadiative_, *atomicRecombinationRateRadiative_, *atomicRecombinationRateRadiativeCooling_, *atomicIonizationRateCollisional_, *atomicRecombinationRateDielectronic_, *atomicIonizationPotential_, *atomicExcitationRateCollisional_, *gauntFactor_"/>

    ! Initialize count of outputs. (Just 1, for temperature.)
    self%countOutputs_=1_c_size_t
    ! Extract elements to compute.
    self%countElements=size(elements)
    self%indexHydrogen=-1
    allocate(self%elementAtomicNumbers         (self%countElements))
    allocate(self%elementAtomicMasses          (self%countElements))
    allocate(self%numberDensityMassDensityRatio(self%countElements))
    ! Get an abundance pattern and compute conversion factors from total gas-phase mass density to atomic number densities (in
    ! cm⁻³) for each element.    
    self%indexAbundancePattern= Abundance_Pattern_Lookup(abundanceName=char(abundancePattern))
    call abundances_%metallicitySet(metallicity,metallicityType=metallicityTypeLinearByMassSolar,adjustElements=adjustElementsReset,abundanceIndex=self%indexAbundancePattern)
    numberDensityMassDensityRatioHydrogen=+abundances_   %hydrogenMassFraction(               )    &
         &                                /Atomic_Mass                        (shortLabel='H' )    &
         &                                /atomicMassUnit                                          &
         &                                *massSolar                                               &
         &                                /megaParsec                                          **3 &
         &                                *centi                                               **3
    numberDensityMassDensityRatioHelium  =+abundances_   %heliumMassFraction  (               )    &
         &                                /Atomic_Mass                        (shortLabel='He')    &
         &                                /atomicMassUnit                                          &
         &                                *massSolar                                               &
         &                                /megaParsec                                          **3 &
         &                                *centi                                               **3
    allocate(abundancesRelative(abundances_%serializeCount()))
    call abundances_%serialize(abundancesRelative)
    do i=1,self%countElements
       self%elementAtomicNumbers(i)=Atomic_Number(shortLabel=trim(self%elements(i)))
       self%elementAtomicMasses (i)=Atomic_Mass  (shortLabel=trim(self%elements(i)))
       self%countOutputs_=self%countOutputs_+self%elementAtomicNumbers(i)+1_c_size_t
       if (outputRates) self%countOutputs_=self%countOutputs_+2*self%elementAtomicNumbers(i)
       select case (self%elementAtomicNumbers(i))
       case (1)     ! Hydrogen
          self%numberDensityMassDensityRatio(i)=+numberDensityMassDensityRatioHydrogen
          self%indexHydrogen                   = i
       case (2)     ! Helium
          self%numberDensityMassDensityRatio(i)=+numberDensityMassDensityRatioHelium
       case default ! Metals
          self%numberDensityMassDensityRatio(i)=+numberDensityMassDensityRatioHydrogen                                                                &
               &                                *abundancesRelative                   (           Abundances_Index_From_Name(trim(self%elements(i)))) &
               &                                *Atomic_Mass                          (shortLabel='H'                                               ) &
               &                                /self%elementAtomicMasses             (                                                         i   )
       end select
    end do
    return
  end function atomicConstructorInternal

  subroutine atomicDestructor(self)
    !% Destructor for the {\normalfont \ttfamily atomic} radiative transfer matter class.
    implicit none
    type(radiativeTransferMatterAtomic), intent(inout) :: self

    !# <objectDestructor name="self%massDistribution_"                       />
    !# <objectDestructor name="self%atomicCrossSectionIonizationPhoto_"      />
    !# <objectDestructor name="self%atomicRecombinationRateRadiative_"       />
    !# <objectDestructor name="self%atomicRecombinationRateRadiativeCooling_"/>
    !# <objectDestructor name="self%atomicIonizationRateCollisional_"        />
    !# <objectDestructor name="self%atomicRecombinationRateDielectronic_"    />
    !# <objectDestructor name="self%atomicIonizationPotential_"              />
    !# <objectDestructor name="self%atomicExcitationRateCollisional_"        />
    !# <objectDestructor name="self%gauntFactor_"                            />
    return
  end subroutine atomicDestructor

  subroutine atomicPropertyClass(self,properties)
    !% Return the property class to use for the computational domain.
    implicit none
    class(radiativeTransferMatterAtomic    ), intent(inout)              :: self
    class(radiativeTransferPropertiesMatter), intent(inout), allocatable :: properties
    !$GLC attributes unused :: self
    
    allocate(radiativeTransferPropertiesMatterAtomic :: properties)
    return
  end subroutine atomicPropertyClass
  
  subroutine atomicPopulateDomain(self,properties,integrator,onProcess)
    !% Populate a computational domain cell with atomic matter.
    use :: Galacticus_Error, only : Galacticus_Error_Report
    implicit none
    class           (radiativeTransferMatterAtomic           ), intent(inout) :: self
    class           (radiativeTransferPropertiesMatter       ), intent(inout) :: properties
    class           (computationalDomainVolumeIntegratorClass), intent(inout) :: integrator
    logical                                                   , intent(in   ) :: onProcess
    double precision                                                          :: densityCell
    integer                                                                   :: i

    select type (properties)
    type is (radiativeTransferPropertiesMatterAtomic)
       ! Initialize properties:
       ! + Assume that the atomic species are fully neutral initially.
       ! + Assign an initial temperature.
       ! + Initialize photoionization and photo heating rates to impossible values. These will be used as the "previous" value on
       !   the first iteration, guaranteeing that our first iteration is never judged to be converged.
       properties%iterationCount=+0
       properties%temperature   =self%temperatureMinimum
       properties%volume        =+integrator%volume()
       allocate(properties%elements(self%countElements))
       do i=1,self%countElements
          allocate(properties%elements(i)%photoIonizationRateHistory(self%iterationAverageCount,0:self%elementAtomicNumbers(i)-1))
          allocate(properties%elements(i)%photoHeatingRateHistory   (self%iterationAverageCount,0:self%elementAtomicNumbers(i)-1))
          allocate(properties%elements(i)%ionizationStateFraction   (                           0:self%elementAtomicNumbers(i)  ))
          allocate(properties%elements(i)%photoIonizationRate       (                           0:self%elementAtomicNumbers(i)-1))
          allocate(properties%elements(i)%photoHeatingRate          (                           0:self%elementAtomicNumbers(i)-1))
          properties%elements(i)%ionizationStateFraction      =      0.0d0
          properties%elements(i)%ionizationStateFraction   (0)=      1.0d0
          properties%elements(i)%photoIonizationRate          =-huge(0.0d0)
          properties%elements(i)%photoHeatingRate             =-huge(0.0d0)
          properties%elements(i)%photoIonizationRateHistory   =-huge(0.0d0)
          properties%elements(i)%photoHeatingRateHistory      =-huge(0.0d0)
       end do
       ! Compute the number density of this atomic species.
       if (onProcess) then
          densityCell                      =+integrator %integrate                    (atomicDensityIntegrand) &
               &                            /properties %volume
          properties%elements%densityNumber=+densityCell                                                       &
               &                            *self       %numberDensityMassDensityRatio
       end if
    class default
       call Galacticus_Error_Report('incorrect class'//{introspection:location})
    end select
    return

  contains

    double precision function atomicDensityIntegrand(coordinates)
      !% Integrand of atomic matter density.
      use :: Coordinates, only : coordinate
      implicit none
      class(coordinate), intent(in   ) :: coordinates
      
      atomicDensityIntegrand= self%massDistribution_%density(coordinates)
      return
    end function atomicDensityIntegrand

  end subroutine atomicPopulateDomain

#ifdef USEMPI
  subroutine atomicBroadcastDomain(self,sendFromProcess,properties)
    !% Broadcast populated computational domain properties to other MPI processes.
    use :: Galacticus_Error, only : Galacticus_Error_Report
    use :: MPI_Utilities   , only : mpiSelf
    implicit none
    class  (radiativeTransferMatterAtomic    ), intent(inout) :: self
    integer                                   , intent(in   ) :: sendFromProcess
    class  (radiativeTransferPropertiesMatter), intent(inout) :: properties
    !$GLC attributes unused :: self

    select type (properties)
    type is (radiativeTransferPropertiesMatterAtomic)
       call mpiSelf%broadcastData(sendFromProcess,properties%elements%densityNumber)
    class default
       call Galacticus_Error_Report('incorrect class'//{introspection:location})
    end select
    return
  end subroutine atomicBroadcastDomain
#endif
  
  subroutine atomicReset(self,properties)
    !% Reset a computational domain cell prior to a new iteration.
    use :: Galacticus_Error, only : Galacticus_Error_Report
    implicit none
    class  (radiativeTransferMatterAtomic    ), intent(inout) :: self
    class  (radiativeTransferPropertiesMatter), intent(inout) :: properties
    integer                                                   :: i
    
    select type (properties)
    type is (radiativeTransferPropertiesMatterAtomic)
       ! Store the current photoionization and photoheating rates as the "previous" values, and then reset these rates to zero.
       do i=1,self%countElements
          properties%elements(i)%photoIonizationRatePrevious=properties%elements(i)%photoIonizationRate
          properties%elements(i)%photoHeatingRatePrevious   =properties%elements(i)%photoHeatingRate
          properties%elements(i)%photoIonizationRate        =0.0d0
          properties%elements(i)%photoHeatingRate           =0.0d0
       end do
       properties               %iterationCount             =properties            %iterationCount     +1
    class default
       call Galacticus_Error_Report('incorrect class'//{introspection:location})
    end select
    return
  end subroutine atomicReset

  double precision function atomicAbsorptionCoefficient(self,properties,photonPacket)
    !% Return the absorption coefficient for the given photon packet and matter properties.
    use :: Galacticus_Error                , only : Galacticus_Error_Report
    use :: Numerical_Constants_Astronomical, only : megaParsec
    use :: Numerical_Constants_Prefixes    , only : centi
    use :: Numerical_Constants_Units       , only : angstromsPerMeter
    implicit none
    class           (radiativeTransferMatterAtomic     ), intent(inout) :: self
    class           (radiativeTransferPropertiesMatter ), intent(inout) :: properties
    class           (radiativeTransferPhotonPacketClass), intent(inout) :: photonPacket
    double precision                                                    :: crossSectionPhotoIonization
    integer                                                             :: i                          , j, &
         &                                                                 k                          , n, &
         &                                                                 l                          , m, &
         &                                                                 countElectrons
    
    select type (properties)
    type is (radiativeTransferPropertiesMatterAtomic)
       atomicAbsorptionCoefficient=0.0d0
       do i=1,self%countElements
          do j=0,self%elementAtomicNumbers(i)-1 ! j=0 is neutral atom; j=1 is first ionized state, etc.
             ! Determine the maximum sub-shell occupied by electrons. Sub-shell number is 1s=1, 2s=2, 2p=3, 3s=4, etc.
             countElectrons=0
             n             =0
             m             =0
             do while (countElectrons < self%elementAtomicNumbers(i)-j)
                n=n+1
                l=-1
                do while (l < n-1)
                   l             =l             +1
                   m             =m             +1
                   countElectrons=countElectrons+4*l+2
                   if (countElectrons >= self%elementAtomicNumbers(i)-j) exit
                end do
             end do
             crossSectionPhotoIonization=0.0d0
             do k=1,m
                crossSectionPhotoIonization=+crossSectionPhotoIonization                                                                                  &
                     &                      +self%atomicCrossSectionIonizationPhoto_%crossSection(                                                        &
                     &                                                                            atomicNumber   =self        %elementAtomicNumbers(i  ), &
                     &                                                                            ionizationState=                                  j+1 , &
                     &                                                                            shellNumber    =                                  k   , &
                     &                                                                            wavelength     =photonPacket%wavelength          (   )  &
                     &                                                                           )
             end do
             atomicAbsorptionCoefficient=+atomicAbsorptionCoefficient                       &
                  &                      +crossSectionPhotoIonization                       &
                  &                      *properties%elements(i)%densityNumber              &
                  &                      *properties%elements(i)%ionizationStateFraction(j) &
                  &                      /centi                                             &
                  &                      *megaParsec
          end do
       end do
    class default
       atomicAbsorptionCoefficient=0.0d0
       call Galacticus_Error_Report('incorrect class'//{introspection:location})
    end select
    return
  end function atomicAbsorptionCoefficient

  subroutine atomicAccumulatePhotonPacket(self,properties,photonPacket,absorptionCoefficient,lengthTraversed)
    !% Accumulate a photon packet.
    use :: Galacticus_Error                , only : Galacticus_Error_Report
    use :: Numerical_Constants_Astronomical, only : luminositySolar        , megaParsec
    use :: Numerical_Constants_Physical    , only : plancksConstant        , speedLight
    use :: Numerical_Constants_Prefixes    , only : centi
    use :: Numerical_Constants_Units       , only : angstromsPerMeter      , electronVolt
    implicit none
    class           (radiativeTransferMatterAtomic     ), intent(inout) :: self
    class           (radiativeTransferPropertiesMatter ), intent(inout) :: properties
    class           (radiativeTransferPhotonPacketClass), intent(inout) :: photonPacket
    double precision                                    , intent(in   ) :: absorptionCoefficient      , lengthTraversed
    double precision                                                    :: energyPhoton               , rateIonization             , &
         &                                                                 crossSectionPhotoIonization, atomicAbsorptionCoefficient
    integer                                                             :: i                          , j                          , &
         &                                                                 k                          , n                          , &
         &                                                                 l                          , m                          , &
         &                                                                 countElectrons
    !$GLC attributes unused :: absorptionCoefficient

    select type (properties)
    type is (radiativeTransferPropertiesMatterAtomic)
       ! Accumulate the photoionization rate per unit volume (cm⁻³), and photoheating rate per unit volume (J cm⁻³) using the Lucy
       ! (1999; A&A; 344; 282; https://ui.adsabs.harvard.edu/abs/1999A%26A...344..282L; see section 3.4) methodology.
       energyPhoton=+plancksConstant               &
            &       *speedLight                    &
            &       *angstromsPerMeter             &
            &       /photonPacket     %wavelength()
       do i=1,self%countElements
          do j=0,self%elementAtomicNumbers(i)-1 ! j=0 is neutral atom; j=1 is first ionized state, etc.
             ! Determine the maximum sub-shell occupied by electrons. Sub-shell number is 1s=1, 2s=2, 2p=3, 3s=4, etc.
             countElectrons=0
             n             =0
             m             =0
             do while (countElectrons < self%elementAtomicNumbers(i)-j)
                n=n+1
                l=-1
                do while (l < n-1)
                   l             =l             +1
                   m             =m             +1
                   countElectrons=countElectrons+4*l+2
                   if (countElectrons >= self%elementAtomicNumbers(i)-j) exit
                end do
             end do
             crossSectionPhotoIonization=0.0d0
             do k=1,m
                crossSectionPhotoIonization=+crossSectionPhotoIonization                                                                                  &
                     &                      +self%atomicCrossSectionIonizationPhoto_%crossSection(                                                        &
                     &                                                                            atomicNumber   =self        %elementAtomicNumbers(i  ), &
                     &                                                                            ionizationState=                                  j+1 , &
                     &                                                                            shellNumber    =                                  k   , &
                     &                                                                            wavelength     =photonPacket%wavelength          (   )  &
                     &                                                                           )
             end do
             atomicAbsorptionCoefficient                  =+crossSectionPhotoIonization                                                                                                                       &
                  &                                        *properties                 %elements                  (i)%densityNumber                                                                           &
                  &                                        *properties                 %elements                  (i)%ionizationStateFraction(                                                          j)    &
                  &                                        /centi                                                                                                                                             &
                  &                                        *megaParsec 
             rateIonization                               =+photonPacket                                             %luminosity             (                                                           )    &
                  &                                        *luminositySolar                                                                                                                                   &
                  &                                        /energyPhoton                                                                                                                                      &
                  &                                        *atomicAbsorptionCoefficient                                                                                                                       &
                  &                                        *lengthTraversed                                                                                                                                   &
                  &                                        /properties                                               %volume                                                                                  &
                  &                                        *centi                                                                                                                                         **3 &
                  &                                        /megaParsec                                                                                                                                    **3
             properties%elements(i)%photoIonizationRate(j)=+properties                 %elements                  (i)%photoIonizationRate    (                                                          j)    &
                  &                                        +rateIonization
             properties%elements(i)%photoHeatingRate   (j)=+properties                 %elements                  (i)%photoHeatingRate       (                                                          j)    &
                  &                                        +rateIonization                                                                                                                                    &
                  &                                        *(                                                                                                                                                 &
                  &                                          +energyPhoton                                                                                                                                    &
                  &                                          -self                     %atomicIonizationPotential_   %potential              (self%elementAtomicNumbers(i),self%elementAtomicNumbers(i)-j)    &
                  &                                          *electronVolt                                                                                                                                    &
                  &                                         )
          end do
       end do
    class default
       call Galacticus_Error_Report('incorrect class'//{introspection:location})
    end select
    return
  end subroutine atomicAccumulatePhotonPacket

  logical function atomicInteractWithPhotonPacket(self,properties,photonPacket)
    !% Interact with a photon packet. In this case the photon packet is always absorbed.
    implicit none
    class(radiativeTransferMatterAtomic     ), intent(inout) :: self
    class(radiativeTransferPropertiesMatter ), intent(inout) :: properties
    class(radiativeTransferPhotonPacketClass), intent(inout) :: photonPacket
    !$GLC attributes unused :: self, properties, photonPacket
    
    atomicInteractWithPhotonPacket=.false.
    return
  end function atomicInteractWithPhotonPacket

#ifdef USEMPI
  subroutine atomicAccumulationReduction(self,properties)
    !% Perform reduction of accumulated properaties across MPI processes.
    use :: Galacticus_Error, only : Galacticus_Error_Report
    use :: MPI_Utilities   , only : mpiSelf
    implicit none
    class  (radiativeTransferMatterAtomic    ), intent(inout)  :: self
    class  (radiativeTransferPropertiesMatter), intent(inout)  :: properties
    integer                                                    :: i
    
    select type (properties)
    type is (radiativeTransferPropertiesMatterAtomic)
       do i=1,self%countElements
          properties%elements(i)%photoIonizationRate=mpiSelf%sum(properties%elements(i)%photoIonizationRate)
          properties%elements(i)%photoHeatingRate   =mpiSelf%sum(properties%elements(i)%photoHeatingRate   )
       end do
    class default
       call Galacticus_Error_Report('incorrect class'//{introspection:location})
    end select
    return
  end subroutine atomicAccumulationReduction
#endif

  double precision function atomicStateThermalBalance(temperature)
    !% Root function used in finding the equilibrium temperature for thermal balance.
    use :: Numerical_Constants_Physical, only : boltzmannsConstant, speedLight, electronMass, fineStructure, &
         &                                      electronRadius
    use :: Numerical_Constants_Math    , only : Pi
    use :: Numerical_Constants_Prefixes, only : centi
    implicit none
    double precision, intent(in   ) :: temperature
    double precision                :: chargeIonic
    integer                         :: i          , j

    atomicStateThermalBalance=0.0d0
    ! Iterate over all states of all elements, accumulating heating/cooling rates and computing the equilibrium ionization fractions.
    do i=1,atomicSelf%countElements
       do j=0,atomicSelf%elementAtomicNumbers(i)
          ! Accumulate the photo-heating rate.
          if (j < atomicSelf%elementAtomicNumbers(i)) atomicStateThermalBalance=+atomicStateThermalBalance                        &
               &                                                                +atomicElementsPhotoRate  (i)%photoHeatingRate(j)
          !! Accumulate rate of collisional excitation cooling.
          if  (j < atomicSelf%elementAtomicNumbers(i))                                                                                                                       &
               & atomicStateThermalBalance=+atomicStateThermalBalance                                                                                                        &
               &                           -atomicDensityNumberElectrons                                                                                                     &
               &                           *atomicProperties%elements                        (i)%densityNumber                                                               &
               &                           *atomicProperties%elements                        (i)%ionizationStateFraction(                                   j              ) &
               &                           *atomicSelf      %atomicExcitationRateCollisional_   %coolingRate            (atomicSelf%elementAtomicNumbers(i),j+1,temperature) &
               &                           /centi**3
          !! Accumulate rate of Bremsstrahlung cooling.
          if (j > 0) then
             chargeIonic              =dble(j)
             atomicStateThermalBalance=+atomicStateThermalBalance                                                                                     &
                  &                    -16.0d0                                                                                                        &
                  &                    / 3.0d0                                                                                                        &
                  &                    *sqrt(                                                                                                         &
                  &                          +2.0d0                                                                                                   &
                  &                          *Pi                                                                                                      &
                  &                          /3.0d0                                                                                                   &
                  &                         )                                                                                                         &
                  &                    *chargeIonic**2                                                                                                &
                  &                    *atomicProperties%elements(i)%densityNumber                                                                    &
                  &                    *atomicProperties%elements(i)%ionizationStateFraction      (                                   j             ) &
                  &                    *atomicDensityNumberElectrons                                                                                  &
                  &                    *electronRadius          **3                                                                                   &
                  &                    *speedLight                                                                                                    &
                  &                    /electronRadius                                                                                                &
                  &                    *sqrt(                                                                                                         &
                  &                          +electronMass                                                                                            &
                  &                          *speedLight        **2                                                                                   &
                  &                          *boltzmannsConstant                                                                                      &
                  &                          *temperature                                                                                             &
                  &                         )                                                                                                         &
                  &                    *fineStructure                                                                                                 &
                  &                    *atomicSelf                  %gauntFactor_           %total(atomicSelf%elementAtomicNumbers(i),j,temperature)  &
                  &                    /centi**3
             !! Accumulate the rates of cooling due to recombinations.
             atomicStateThermalBalance=+                                                       atomicStateThermalBalance                                                                                     &
                  &                    -atomicSelf      %atomicRecombinationRateRadiativeCooling_   %rate                   (atomicSelf%elementAtomicNumbers(i),j,temperature,level=atomicRecombinationCase) &
                  &                    *boltzmannsConstant                                                                                                                                                   &
                  &                    *temperature                                                                                                                                                          &
                  &                    *atomicDensityNumberElectrons                                                                                                                                         &
                  &                    *atomicProperties%elements                                (i)%densityNumber                                                                                           &
                  &                    *atomicProperties%elements                                (i)%ionizationStateFraction(                                   j                                          )
             atomicStateThermalBalance=+atomicStateThermalBalance                                                                                                                                            &
                  &                    -0.0d0 !! TO DO - get dielectronic cooling rates.     
          end if
       end do
    end do
    return
  end function atomicStateThermalBalance
  
  subroutine atomicStateSolve(self,properties,status)
    !% Solve for the state of the matter.
    use :: Atomic_Rates_Recombination_Radiative, only : recombinationCaseA       , recombinationCaseB
    use :: Galacticus_Display                  , only : Galacticus_Display_Indent, Galacticus_Display_Unindent, Galacticus_Display_Message   , verbosityStandard
    use :: Galacticus_Error                    , only : Galacticus_Error_Report  , errorStatusSuccess         , errorStatusFail              , errorStatusOutOfRange
    use :: Root_Finder                         , only : rangeExpandMultiplicative, rootFinder                 , rangeExpandSignExpectNegative, rangeExpandSignExpectPositive
    use :: Numerical_Roman_Numerals            , only : Roman_Numerals
    implicit none
    class           (radiativeTransferMatterAtomic    ), intent(inout) , target      :: self
    class           (radiativeTransferPropertiesMatter), intent(inout) , target      :: properties
    integer                                            , intent(  out) , optional    :: status
    double precision                                   , dimension(2)                :: temperaturePrevious                            , densityElectronsPrevious
    double precision                                   , parameter                   :: temperatureToleranceRelative            =1.0d-2, temperatureToleranceAbsolute =1.0d+0
    integer                                            , parameter                   :: countIterationMaximum                   =1000  , temperatureOscillatingCounts =30    , &
         &                                                                              electronsOscillatingCounts              =30
    double precision                                   , parameter                   :: degreesOfFreedom                        =3.0d+0
    double precision                                   , parameter                   :: temperatureMaximum                      =1.0d+7
    type            (element                          ), dimension( : ), allocatable :: elementsPrevious                               , elementsReference
    double precision                                                                 :: rateRecombinationRadiative                     , rateRecombinationDielectronic       , &
         &                                                                              temperatureChangePrevious                      , temperatureEquilibrium              , &
         &                                                                              rateUpward                                     , rateDownward                        , &
         &                                                                              temperatureReference
    logical                                                                          :: converged                                      , temperatureOscillating              , &
         &                                                                              electronsOscillating                           , heatingNonZero
    integer                                                                          :: countIteration                                 , i                                   , &
         &                                                                              temperatureOscillatingCount                    , j                                   , &
         &                                                                              electronsOscillatingCount                      , statusTemperature                   , &
         &                                                                              exponentIonizationStateFractionMaximum         , exponentIonizationState
    type            (rootFinder                       ), save                        :: finder
    !$omp threadprivate(finder)
#ifdef RADTRANSDEBUG
    integer                                                                          :: handlerPrevious
#endif
    character       (len=256                         )                               :: message
    
#ifdef RADTRANSDEBUG
    handlerPrevious=Signal(8,debugAbort)
#endif
    if (present(status)) status=errorStatusSuccess
    select type (properties)
    type is (radiativeTransferPropertiesMatterAtomic)
       ! Set module-scope pointers to self and properties.
       atomicSelf       => self
       atomicProperties => properties
       ! Initialize root finder.
       if (.not.finder%isInitialized()) then
          call finder   %tolerance          (                                                                  &
               &                             toleranceRelative            =     temperatureToleranceRelative , &
               &                             toleranceAbsolute            =     temperatureToleranceAbsolute   &
               &                            )
          call finder   %rangeExpand        (                                                                  &
               &                             rangeExpandUpward            =     2.0d0                        , &
               &                             rangeExpandDownward          =     0.5d0                        , &
               &                             rangeExpandUpwardSignExpect  =     rangeExpandSignExpectNegative, &
               &                             rangeExpandDownwardSignExpect=     rangeExpandSignExpectPositive, &
               &                             rangeUpwardLimit             =     temperatureMaximum           , &
               &                             rangeDownwardLimit           =self%temperatureMinimum           , &
               &                             rangeExpandType              =     rangeExpandMultiplicative      &
               &                            )
          call finder   %rootFunction       (                                                                  &
               &                                                                atomicStateThermalBalance      &
               &                            )
       end if
       ! Append the accumulated photoionization/photoheating rates to the history arrays, compute the average over those
       ! histories, and replace the photoionization/photoheating rates with those averages.
       if (self%iterationAverageCount > 1) then
          do i=1,self%countElements
             properties%elements(i)%photoIonizationRateHistory(2:self%iterationAverageCount,:)=properties%elements(i)%photoIonizationRateHistory(1:self%iterationAverageCount-1,:)
             properties%elements(i)%photoHeatingRateHistory   (2:self%iterationAverageCount,:)=properties%elements(i)%photoHeatingRateHistory   (1:self%iterationAverageCount-1,:)
             properties%elements(i)%photoIonizationRateHistory(1                           ,:)=properties%elements(i)%photoIonizationRate       (                               :)
             properties%elements(i)%photoHeatingRateHistory   (1                           ,:)=properties%elements(i)%photoHeatingRate          (                               :)
             do j=0,self%elementAtomicNumbers(i)-1
                properties%elements(i)%photoIonizationRate(j)=+sum (properties%elements(i)%photoIonizationRateHistory(1:min(properties%iterationCount,self%iterationAverageCount),j)) &
                     &                                        /dble(                                                    min(properties%iterationCount,self%iterationAverageCount)   )
                properties%elements(i)%photoHeatingRate   (j)=+sum (properties%elements(i)%photoHeatingRateHistory   (1:min(properties%iterationCount,self%iterationAverageCount),j)) &
                     &                                        /dble(                                                    min(properties%iterationCount,self%iterationAverageCount)   )
             end do
          end do
       end if
       ! Create array of elements matched to that in the domain cell.
       allocate(elementsPrevious       (self%countElements))
       allocate(elementsReference      (self%countElements))
       allocate(atomicElementsPhotoRate(self%countElements))
       do i=1,self%countElements
          allocate(elementsPrevious       (i)%ionizationStateFraction(size(properties%elements(i)%ionizationStateFraction)))
          allocate(elementsReference      (i)%ionizationStateFraction(size(properties%elements(i)%ionizationStateFraction)))
          allocate(atomicElementsPhotoRate(i)%ionizationStateFraction(size(properties%elements(i)%ionizationStateFraction)))
          allocate(elementsPrevious       (i)%photoIonizationRate    (size(properties%elements(i)%photoIonizationRate    )))
          allocate(elementsReference      (i)%photoIonizationRate    (size(properties%elements(i)%photoIonizationRate    )))
          allocate(atomicElementsPhotoRate(i)%photoIonizationRate    (size(properties%elements(i)%photoIonizationRate    )))
          allocate(elementsPrevious       (i)%photoHeatingRate       (size(properties%elements(i)%photoHeatingRate       )))
          allocate(elementsReference      (i)%photoHeatingRate       (size(properties%elements(i)%photoHeatingRate       )))
          allocate(atomicElementsPhotoRate(i)%photoHeatingRate       (size(properties%elements(i)%photoHeatingRate       )))
       end do
       elementsPrevious       =properties%elements
       elementsReference      =properties%elements
       atomicElementsPhotoRate=properties%elements
       ! Iterate until convergence is achieved.
       converged                  =all(properties%elements(:)%densityNumber <= 0.0d0)
       countIteration             =0
       temperaturePrevious        =properties%temperature
       temperatureReference       =properties%temperature
       densityElectronsPrevious   =0.0d0
       temperatureChangePrevious  =0.0d0
       temperatureOscillating     =.false.
       electronsOscillating       =.false.
       temperatureOscillatingCount=0
       electronsOscillatingCount  =0
       do i=1,self%countElements
          elementsPrevious (i)%ionizationStateFraction=properties%elements(i)%ionizationStateFraction
          elementsReference(i)%ionizationStateFraction=properties%elements(i)%ionizationStateFraction
          if (.not.converged) then
             elementsPrevious(i)%photoHeatingRate   =+properties%elements(i)%photoHeatingRate
             if (properties%elements(i)%densityNumber > 0.0d0) then
                elementsPrevious(i)%photoIonizationRate=+properties%elements(i)%photoIonizationRate &
                     &                                  /properties%elements(i)%densityNumber
             else
                elementsPrevious(i)%photoIonizationRate=+0.0d0
             end if
          end if
       end do
       do while (.not.converged)
          ! Compute total electron density and particle density.
          atomicDensityNumberElectrons=0.0d0
          do i=1,self%countElements
             do j=1,self%elementAtomicNumbers(i)
                atomicDensityNumberElectrons=+                       atomicDensityNumberElectrons    &
                     &                       +properties%elements(i)%densityNumber                   &
                     &                       *properties%elements(i)%ionizationStateFraction     (j) &
                     &                       *dble                                               (j)
             end do
          end do
          if (electronsOscillatingCount > 0) &
               & atomicDensityNumberElectrons=0.5d0*(atomicDensityNumberElectrons+densityElectronsPrevious(1))
          ! Compute rates of change of the ionization states and temperature.
          !! Initialize rates and computed photoionization and photoheating rates.
          heatingNonZero=.false.
          do i=1,self%countElements
             do j=0,self%elementAtomicNumbers(i)-1
                ! Compute the photoionization rate.
                if (properties%elements(i)%densityNumber > 0.0d0) then
                   atomicElementsPhotoRate (i)%photoIonizationRate(j)=+properties%elements(i)%photoIonizationRate(j) &
                        &                                             /properties%elements(i)%densityNumber
                else
                   atomicElementsPhotoRate (i)%photoIonizationRate(j)=+0.0d0
                end if
                ! Compute photoheating rates (in W cm⁻³).
                atomicElementsPhotoRate    (i)%photoHeatingRate   (j)=+properties%elements(i)%photoHeatingRate   (j)
                if (atomicElementsPhotoRate(i)%photoHeatingRate   (j) > 0.0d0) heatingNonZero=.true.
             end do
             ! For the fully-ionized state, use a photoionization rate from the lower state - this is just used for scaling timescales.
             atomicElementsPhotoRate(i)%photoIonizationRate(self%elementAtomicNumbers(i))=atomicElementsPhotoRate(i)%photoIonizationRate(self%elementAtomicNumbers(i)-1)
             atomicElementsPhotoRate(i)%photoHeatingRate   (self%elementAtomicNumbers(i))=atomicElementsPhotoRate(i)%photoHeatingRate   (self%elementAtomicNumbers(i)-1)
          end do
          ! If there is photoheating occuring, solve for the state of matter.
          if (heatingNonZero) then
             ! Iterate over all states of all elements, computing the equilibrium ionization fractions.
             do i=1,self%countElements
                do j=0,self%elementAtomicNumbers(i)
                   if (j == 0) then
                      ! Set the neutral ion fraction to an arbitrary value - we will compute ratios of ionization fractions and
                      ! renormalize at the end.
                      properties%elements(i)%ionizationStateFraction(0)=1.0d0
                   else
                      ! Compute the abundance of this ionization state relative to the lower state by requiring balance between
                      ! ionization and recombination rates.
                      !! Rate of upward transitions from photoionization.
                      if     (                                                                                         &
                           &              elementsReference(i)%ionizationStateFraction(j-1)       > 0.0d0              &
                           &  .and.                                                                                    &
                           &   properties%elements         (i)%densityNumber                      > 0.0d0              &
                           &  .and.                                                                                    &
                           &   +exponent(atomicElementsPhotoRate(i)%photoIonizationRate    (j-1))                      &
                           &   -exponent(elementsReference      (i)%ionizationStateFraction(j-1)) < maxExponent(0.0d0) &
                           & ) then
                         rateUpward=+atomicElementsPhotoRate(i)%photoIonizationRate    (j-1) &
                              &     /elementsReference      (i)%ionizationStateFraction(j-1)
                      else
                         rateUpward=+0.0d0
                      end if
                      ! Rate of upward transitions from collisional ionizations.
                      rateUpward=+                                      rateUpward                                                                          &
                           &     +                                      atomicDensityNumberElectrons                                                        &
                           &     *self%atomicIonizationRateCollisional_%rate                        (self%elementAtomicNumbers(i),j,properties%temperature)
                      !! Rates of downward transitions from radiative and dielectronic recombintions.
                      select case (self%elementAtomicNumbers(i))
                      case (1,2)
                         ! Hydrogen, helium.
                         !! TO DO - hard-coded for case-B recombination
                         atomicRecombinationCase=recombinationCaseB
                      case default
                         ! Metals.
                         atomicRecombinationCase=recombinationCaseA
                      end select
                      rateRecombinationRadiative   =+                                          atomicDensityNumberElectrons                                                                                      &
                           &                        *self%atomicRecombinationRateRadiative_   %rate                        (self%elementAtomicNumbers(i),j,properties%temperature,level=atomicRecombinationCase)
                      rateRecombinationDielectronic=+                                          atomicDensityNumberElectrons                                                                                      &
                           &                        *self%atomicRecombinationRateDielectronic_%rate                        (self%elementAtomicNumbers(i),j,properties%temperature                              )
                      !! Find the net rate of downward transitions.
                      rateDownward                 =+rateRecombinationRadiative                                                                                                                                  &
                           &                        +rateRecombinationDielectronic
                      !! Compute the relative abundance required to balance upward and downward transitions.
                      if (rateDownward == 0.0d0) then
                         if (rateUpward > 0.0d0) then
                            ! If there are no downward transitions, but some upward transitions no solution is available. So simply
                            ! assume that the relative abundance is 1 - this should get corrected in subsequent iterations.
                            properties%elements(i)%ionizationStateFraction(j)=+properties%elements(i)%ionizationStateFraction(j-1)
                         else
                            ! If there are no downward transitions, and no upward transitions then the upper state should have zero
                            ! fraction.
                            properties%elements(i)%ionizationStateFraction(j)=+0.0d0
                         end if
                      else
                         ! Solve for the relative abundance.
                         !! Ensure that the relative abundances are in a range such that the new abundance will not overflow.
                         exponentIonizationState               =+     exponent(properties%elements(i)%ionizationStateFraction(j-1))
                         exponentIonizationStateFractionMaximum=+  maxExponent(0.0d0                                              ) &
                              &                                 -(                                                                  &
                              &                                   +   exponent(rateUpward                                         ) &
                              &                                   -   exponent(rateDownward                                       ) &
                              &                                  )
                         if (exponentIonizationState >= exponentIonizationStateFractionMaximum) &
                              & properties%elements(i)%ionizationStateFraction(0:j-1)=properties%elements(i)%ionizationStateFraction(0:j-1)/dble(radix(0.0d0))**(exponentIonizationState-exponentIonizationStateFractionMaximum+1)
                         !! Compute the relative abundance in this ionization state.
                         properties%elements(i)%ionizationStateFraction   (j)=+properties%elements(i)%ionizationStateFraction(j-1) &
                              &                                               *rateUpward                                          &
                              &                                               /rateDownward
                      end if
                   end if
                   ! Normalize all ionization states computed so far.                
                   properties%elements(i)%ionizationStateFraction(0:j)=+    properties%elements(i)%ionizationStateFraction(0:j)  &
                        &                                              /sum(properties%elements(i)%ionizationStateFraction(0:j))
                end do
                ! Renormalize ionization states so that the summed fraction is 1.
                properties%elements(i)%ionizationStateFraction=+    properties%elements(i)%ionizationStateFraction  &
                     &                                         /sum(properties%elements(i)%ionizationStateFraction)
                ! If electron density is oscillating then bisect the current and previous ionization state fractions.
                if (electronsOscillatingCount > 0) &
                     & properties%elements(i)%ionizationStateFraction=0.5d0*(properties%elements(i)%ionizationStateFraction+elementsPrevious(i)%ionizationStateFraction)
             end do
             ! Decrement electron oscillation count.
             if (electronsOscillatingCount > 0) &
                  & electronsOscillatingCount=electronsOscillatingCount-1
             ! Scale heating rates by the relevant ionization state fraction.
             if (elementsReference         (i)%ionizationStateFraction(j) > 0.0d0)                                                    &
                  & atomicElementsPhotoRate(i)%photoHeatingRate       (j)=+properties%elements         (i)%photoHeatingRate       (j) &
                  &                                                       *properties%elements         (i)%ionizationStateFraction(j) &
                  &                                                       /           elementsReference(i)%ionizationStateFraction(j)
             ! Solve for temperature - updating only if we find a solution in range.
             temperatureEquilibrium=finder%find(rootGuess=properties%temperature,status=statusTemperature)
             if (statusTemperature == errorStatusSuccess) then
                properties%temperature=temperatureEquilibrium
             else
                ! Temperature solution failed. Attempt to adjust the temperature slightly to allow us to find a solution on
                ! subsequent iterations.
                if      (atomicStateThermalBalance(self%temperatureMinimum) < 0.0d0) then
                   properties%temperature=max(properties%temperature/1.1d0,self%temperatureMinimum)
                else if (atomicStateThermalBalance(     temperatureMaximum) > 0.0d0) then
                   properties%temperature=min(properties%temperature*1.1d0,     temperatureMaximum)
                end if
             end if
             ! If temperature is oscillating bisect the temperature, and then decrease the count of steps for which we attempted
             ! to break out of oscillation.
             if (temperatureOscillatingCount > 0) then
                properties%temperature=0.5d0*(properties%temperature+temperaturePrevious(1))
                if (temperatureOscillatingCount > 0) temperatureOscillatingCount=+temperatureOscillatingCount &
                     &                                                           -1
             end if
          else
             ! No photo-heating - set to minimum temperature and fully neutral.
             statusTemperature     =errorStatusSuccess
             properties%temperature=self%temperatureMinimum
             do i=1,self%countElements
                properties%elements(i)%ionizationStateFraction   =0.0d0
                properties%elements(i)%ionizationStateFraction(0)=1.0d0
             end do
          end if
          ! Check for convergence.
          converged=       statusTemperature                              ==     errorStatusSuccess                                                                &
               &    .and.                                                                                                                                          &
               &     (                                                                                                                                             &
               &       abs(properties%temperature-temperaturePrevious(1)) <  max(temperatureToleranceAbsolute,temperatureToleranceRelative*properties%temperature) &
               &      .or.                                                                                                                                         &
               &       abs(properties%temperature-temperaturePrevious(1)) <      temperatureToleranceAbsolute                                                      &
               &     )
          do i=1,self%countElements
             if (.not.converged) exit
             converged=all(                                                                                                                                                   &
                  &         abs(properties%elements(i)%ionizationStateFraction-elementsPrevious(i)%ionizationStateFraction)                                                   &
                  &        <                                                                                                                                                  &
                  &         max(atomicIonizationStateFractionToleranceAbsolute,atomicIonizationStateFractionToleranceRelative*properties%elements(i)%ionizationStateFraction) &
                  &       )
          end do
          ! Check for exceeding maximum iterations.
          countIteration=countIteration+1
          if (countIteration > countIterationMaximum .and. .not.converged) then
             if (present(status)) then
                status=errorStatusFail
#ifdef RADTRANSDEBUG
                call Signal(8,handlerPrevious)
#endif
                deallocate(atomicElementsPhotoRate)
                return
             else
                ! No solution was found - report on the state of this domain cell.
                call Galacticus_Display_Indent('failed domain cell state report',verbosityStandard)
                write (message,'(a,e23.16         )') 'volume                                    = ',properties%volume
                call Galacticus_Display_Message(message,verbosityStandard)
                write (message,'(a,e23.16         )') 'initial temperature                       = ',temperatureReference
                call Galacticus_Display_Message(message,verbosityStandard)
                do i=1,self%countElements
                   call Galacticus_Display_Indent('element: '//trim(adjustl(self%elements(i))),verbosityStandard)
                   write (message,'(a,e23.16         )') 'density                                   = ',properties%elements(i)%densityNumber
                   call Galacticus_Display_Message(message,verbosityStandard)
                   do j=0,self%elementAtomicNumbers(i)
                      call Galacticus_Display_Indent('ion: '//trim(adjustl(self%elements(i)))//Roman_Numerals(j+1),verbosityStandard)
                      if (j < self%elementAtomicNumbers(i)) then
                         write (message,'(a,e23.16,a,e23.16)') 'photoionization rate (current : previous) = ',properties%elements         (i)%photoIonizationRate    (j),' : ',properties%elements(i)%photoIonizationRatePrevious(j)
                         call Galacticus_Display_Message(message,verbosityStandard)
                         write (message,'(a,e23.16,a,e23.16)') 'photoheating rate    (current : previous) = ',properties%elements         (i)%photoHeatingRate       (j),' : ',properties%elements(i)%photoHeatingRatePrevious   (j)
                         call Galacticus_Display_Message(message,verbosityStandard)
                      end if
                      write    (message,'(a,e23.16,a,e23.16)') 'initial ionization state                  = ',           elementsReference(i)%ionizationStateFraction(j)
                      call Galacticus_Display_Message(message,verbosityStandard)
                      call Galacticus_Display_Unindent('done',verbosityStandard)
                   end do
                   call Galacticus_Display_Unindent('done',verbosityStandard)
                end do
                call Galacticus_Display_Unindent('done',verbosityStandard)
#ifdef RADTRANSDEBUG
                call debugReport()                
#endif
                call Galacticus_Error_Report('solution not found'//{introspection:location})
             end if
          end if
          ! Check for oscillating temperature or electron density.
          if (countIteration >= temperatureOscillatingCounts) then
             if (temperatureOscillatingCount == 0) then
                temperatureOscillating=(properties%temperature      -temperaturePrevious     (1))*(temperaturePrevious     (1)-temperaturePrevious     (2)) < 0.0d0
                ! If oscillation is detected set the number of steps for which we will attempt to break out of it.
                if (temperatureOscillating) temperatureOscillatingCount=temperatureOscillatingCounts
             end if
             if (electronsOscillatingCount == 0) then
                electronsOscillating  =(atomicDensityNumberElectrons-densityElectronsPrevious(1))*(densityElectronsPrevious(1)-densityElectronsPrevious(2)) < 0.0d0
                ! If oscillation is detected set the number of steps for which we will attempt to break out of it.
                if (electronsOscillating  ) electronsOscillatingCount  =electronsOscillatingCounts
             end if
          end if
          ! Store current state to previous state.
          do i=1,self%countElements
             elementsPrevious(i)%ionizationStateFraction=properties%elements(i)%ionizationStateFraction
          end do
          temperatureChangePrevious        =abs(properties%temperature                 -temperaturePrevious     (1))
          temperaturePrevious           (2)=               temperaturePrevious     (1)
          temperaturePrevious           (1)=    properties%temperature
          densityElectronsPrevious      (2)=               densityElectronsPrevious(1)
          densityElectronsPrevious      (1)=               atomicDensityNumberElectrons
       end do       
    class default
       call Galacticus_Error_Report('incorrect class'//{introspection:location})
    end select
#ifdef RADTRANSDEBUG
    call Signal(8,handlerPrevious)
#endif
    deallocate(atomicElementsPhotoRate)
   return

  contains
    
#ifdef RADTRANSDEBUG
    subroutine debugAbort()
      !% Perform debug reporting and then exit.
      implicit none
      
      call debugReport()
      call Abort      ()
      return
    end subroutine debugAbort
    
    subroutine debugReport()
      !% Report debugging information.
      implicit none
      
      ! Debugging output. Writes the initial state for this failed case in a format that be directly pasted into the
      ! relevant test suite code.
      select type (properties)
      type is (radiativeTransferPropertiesMatterAtomic)
         write    (0,'(a,i1)'         ) "properties            %iterationCount             = "    ,1
         write    (0,'(a,e23.16)'     ) "properties            %volume                     = "    ,properties%volume
         write    (0,'(a,e23.16)'     ) "properties            %temperature                = "    ,temperatureReference
         do i=1,self%countElements
            write (0,'(a,i1,a,e23.16)') "properties%elements(",i,")%densityNumber              = ",properties%elements(i)%densityNumber     
            write (0,'(a,i1,a,$)'     ) "properties%elements(",i,")%ionizationStateFraction    =["
            do j=0,self%elementAtomicNumbers(i)
               if (j < self%elementAtomicNumbers(i)) then
                  write (0,'(e23.16,a,$)') elementsReference(i)%ionizationStateFraction    (j),','
               else
                  write (0,'(e23.16,a)'  ) elementsReference(i)%ionizationStateFraction    (j),']'
               end if
            end do
            write (0,'(a,i1,a,$)'     ) "properties%elements(",i,")%photoIonizationRate        =["
            do j=0,self%elementAtomicNumbers(i)-1
               if (j < self%elementAtomicNumbers(i)-1) then
                  write (0,'(e23.16,a,$)') elementsReference(i)%photoIonizationRate        (j),','
               else
                  write (0,'(e23.16,a)'  ) elementsReference(i)%photoIonizationRate        (j),']'
               end if
            end do
            write (0,'(a,i1,a,$)'     ) "properties%elements(",i,")%photoHeatingRate           =["
            do j=0,self%elementAtomicNumbers(i)-1
               if (j < self%elementAtomicNumbers(i)-1) then
                  write (0,'(e23.16,a,$)') elementsReference(i)%photoHeatingRate           (j),','
               else
                  write (0,'(e23.16,a)'  ) elementsReference(i)%photoHeatingRate           (j),']'
               end if
            end do
            write (0,'(a,i1,a,$)'     ) "properties%elements(",i,")%photoIonizationRatePrevious=["
            do j=0,self%elementAtomicNumbers(i)-1
               if (j < self%elementAtomicNumbers(i)-1) then
                  write (0,'(e23.16,a,$)') elementsReference(i)%photoIonizationRatePrevious(j),','
               else
                  write (0,'(e23.16,a)'  ) elementsReference(i)%photoIonizationRatePrevious(j),']'
               end if
            end do
            write (0,'(a,i1,a,$)'     ) "properties%elements(",i,")%photoHeatingRatePrevious   =["
            do j=0,self%elementAtomicNumbers(i)-1
               if (j < self%elementAtomicNumbers(i)-1) then
                  write (0,'(e23.16,a,$)') elementsReference(i)%photoHeatingRatePrevious   (j),','
               else
                  write (0,'(e23.16,a)'  ) elementsReference(i)%photoHeatingRatePrevious   (j),']'
               end if
            end do
         end do
      end select
      return
    end subroutine debugReport
#endif

  end subroutine atomicStateSolve

#ifdef USEMPI
  subroutine atomicBroadcastState(self,sendFromProcess,properties)
    !% Broadcast computational domain state to other MPI processes.
    use :: Galacticus_Error, only : Galacticus_Error_Report
    use :: MPI_Utilities   , only : mpiSelf
    implicit none
    class  (radiativeTransferMatterAtomic    ), intent(inout) :: self
    integer                                   , intent(in   ) :: sendFromProcess
    class  (radiativeTransferPropertiesMatter), intent(inout) :: properties
    integer                                                   :: i
    
    select type (properties)
    type is (radiativeTransferPropertiesMatterAtomic)
       do i=1,self%countElements
          call mpiSelf%broadcastData(sendFromProcess,properties%elements(i)%photoIonizationRate        )
          call mpiSelf%broadcastData(sendFromProcess,properties%elements(i)%photoIonizationRatePrevious)
          call mpiSelf%broadcastData(sendFromProcess,properties%elements(i)%photoHeatingRate           )
          call mpiSelf%broadcastData(sendFromProcess,properties%elements(i)%photoHeatingRatePrevious   )
          call mpiSelf%broadcastData(sendFromProcess,properties%elements(i)%ionizationStateFraction    )
       end do
       call    mpiSelf%broadcastData(sendFromProcess,properties            %temperature                )
       class default
       call Galacticus_Error_Report('incorrect class'//{introspection:location})
    end select
    return
  end subroutine atomicBroadcastState
#endif
  
  double precision function atomicConvergenceMeasure(self,properties)
    !% Return a convergence measure for the atomic matter.
    use :: Disparity_Ratios, only : Disparity_Ratio
    use :: Galacticus_Error, only : Galacticus_Error_Report
    implicit none
    class  (radiativeTransferMatterAtomic    ), intent(inout) :: self
    class  (radiativeTransferPropertiesMatter), intent(inout) :: properties
    integer                                                   :: i         , j
    !$GLC attributes unused :: self

    select type (properties)
    type is (radiativeTransferPropertiesMatterAtomic)
       atomicConvergenceMeasure=0.0d0
       do i=1,self%countElements
          do j=0,self%elementAtomicNumbers(i)-1
             ! Only consider states with some significant population when computing convergence measure.
             if     (                                                                                                                                                      &
                  &   properties%elements(i)%ionizationStateFraction (j) > atomicIonizationStateFractionToleranceAbsolute                                                  &
                  &  .and.                                                                                                                                                 &
                  &   properties%elements(i)%photoHeatingRatePrevious(j) > 0.0d0                                                                                           &
                  & )                                                                                                                                                      &
                  & atomicConvergenceMeasure=max(                                                                                                                          &
                  &                                 atomicConvergenceMeasure                                                                                             , &
                  &                              max(                                                                                                                      &
                  &                                  Disparity_Ratio(properties%elements(i)%photoIonizationRate(j),properties%elements(i)%photoIonizationRatePrevious(j)), & 
                  &                                  Disparity_Ratio(properties%elements(i)%photoHeatingRate   (j),properties%elements(i)%photoHeatingRatePrevious   (j))  &
                  &                                 )                                                                                                                      &
                  &                             )
          end do
       end do
       class default
       atomicConvergenceMeasure=0.0d0
       call Galacticus_Error_Report('incorrect class'//{introspection:location})
    end select
    return
  end function atomicConvergenceMeasure
  
  double precision function atomicOutputProperty(self,properties,output)
    !% Return a scalar property to be output.
    use :: Galacticus_Error, only : Galacticus_Error_Report
    implicit none
    class  (radiativeTransferMatterAtomic    ), intent(inout) :: self
    class  (radiativeTransferPropertiesMatter), intent(inout) :: properties
    integer(c_size_t                         ), intent(in   ) :: output
    integer(c_size_t                         )                :: output_   , outputCountElement
    integer                                                   :: i
    
    select type (properties)
    type is (radiativeTransferPropertiesMatterAtomic)
       if      (output == 1_c_size_t                                   ) then
          atomicOutputProperty=properties%temperature
       else if (output >= 2_c_size_t .and. output <= self%countOutputs_) then
          output_                  =output                                                    -1_c_size_t
          i                        =                                                           1
          outputCountElement       =                              self%elementAtomicNumbers(i)+1_c_size_t
          if (self%outputRates)                                                                           &
               & outputCountElement=outputCountElement+2_c_size_t*self%elementAtomicNumbers(i)
          do while (output_ > outputCountElement)
             output_                  =output_                                                  -outputCountElement
             i                        =i                                                         +1
             outputCountElement       =                              self%elementAtomicNumbers(i)+1_c_size_t
             if (self%outputRates)                                                                                  &
                  & outputCountElement=outputCountElement+2_c_size_t*self%elementAtomicNumbers(i)
          end do
          if      (output_                                                    == 1_c_size_t                  ) then
             atomicOutputProperty=properties%elements(i)%densityNumber
          else if (output_                                        -1_c_size_t <= self%elementAtomicNumbers(i)) then
             atomicOutputProperty=properties%elements(i)%ionizationStateFraction(output_                                        -1_c_size_t)
          else if (output_-           self%elementAtomicNumbers(i)-1_c_size_t <= self%elementAtomicNumbers(i)) then
             atomicOutputProperty=properties%elements(i)%photoIonizationRate    (output_-           self%elementAtomicNumbers(i)-2_c_size_t)
          else if (output_-2_c_size_t*self%elementAtomicNumbers(i)-1_c_size_t <= self%elementAtomicNumbers(i)) then
             atomicOutputProperty=properties%elements(i)%photoHeatingRate       (output_-2_c_size_t*self%elementAtomicNumbers(i)-2_c_size_t)
          else
             atomicOutputProperty=0.0d0
             call Galacticus_Error_Report('output is out of range (this should not happen)'//{introspection:location})
          end if
       else
          atomicOutputProperty=0.0d0
          call Galacticus_Error_Report('output is out of range'//{introspection:location})
       end if
    class default
       atomicOutputProperty=0.0d0
       call Galacticus_Error_Report('incorrect class'//{introspection:location})
    end select
    return
  end function atomicOutputProperty
  
  function atomicCountOutputs(self)
    !% Return the number of scalar properties to output.
    implicit none
    integer(c_size_t                     )                :: atomicCountOutputs
    class  (radiativeTransferMatterAtomic), intent(inout) :: self
    !$GLC attributes unused :: self

    atomicCountOutputs=self%countOutputs_
    return
  end function atomicCountOutputs

  function atomicOutputName(self,output)
    !% Return the name of the scalar property to be output.
    use :: Galacticus_Error        , only : Galacticus_Error_Report
    use :: ISO_Varying_String      , only : operator(//)
    use :: Numerical_Roman_Numerals, only : Roman_Numerals
    implicit none
    type   (varying_string               )                :: atomicOutputName
    class  (radiativeTransferMatterAtomic), intent(inout) :: self
    integer(c_size_t                     ), intent(in   ) :: output
    integer(c_size_t                     )                :: output_         , outputCountElement
    integer                                               :: i
    
    if      (output == 1_c_size_t                                   ) then
       atomicOutputName=var_str('temperature')
    else if (output >= 2_c_size_t .and. output <= self%countOutputs_) then
       output_                  =output                                                    -1_c_size_t
       i                        =                                                           1
       outputCountElement       =                              self%elementAtomicNumbers(i)+1_c_size_t
       if (self%outputRates)                                                                           &
            & outputCountElement=outputCountElement+2_c_size_t*self%elementAtomicNumbers(i)
       do while (output_ > outputCountElement)
          output_                  =output_                                                  -outputCountElement
          i                        =i                                                         +1
          outputCountElement       =                              self%elementAtomicNumbers(i)+1_c_size_t
          if (self%outputRates)                                                                                  &
               & outputCountElement=outputCountElement+2_c_size_t*self%elementAtomicNumbers(i)
       end do
       if      (output_                                                    == 1_c_size_t                  ) then
          atomicOutputName=var_str('densityNumber'      )//trim(adjustl(self%elements(i)))
       else if (output_                                        -1_c_size_t <= self%elementAtomicNumbers(i)) then
          atomicOutputName=var_str('fraction'           )//trim(adjustl(self%elements(i)))//Roman_Numerals(int(output_                                                   ))
       else if (output_-           self%elementAtomicNumbers(i)-1_c_size_t <= self%elementAtomicNumbers(i)) then
          atomicOutputName=var_str('photoIonizationRate')//trim(adjustl(self%elements(i)))//Roman_Numerals(int(output_-           self%elementAtomicNumbers(i)-1_c_size_t))
       else if (output_-2_c_size_t*self%elementAtomicNumbers(i)-1_c_size_t <= self%elementAtomicNumbers(i)) then
          atomicOutputName=var_str('photoHeatingRate'   )//trim(adjustl(self%elements(i)))//Roman_Numerals(int(output_-2_c_size_t*self%elementAtomicNumbers(i)-1_c_size_t))
       else
          atomicOutputName=var_str(''                   )
          call Galacticus_Error_Report('output is out of range (this should not happen)'//{introspection:location})
       end if
    else
       atomicOutputName=var_str(''                )
       call Galacticus_Error_Report('output is out of range'//{introspection:location})
    end if
    return
  end function atomicOutputName

  double precision function atomicRecombinationRateHydrogen(self,properties)
    !% Return the total recombination rate for the atomic matter.
    use :: Atomic_Rates_Recombination_Radiative, only : recombinationCaseB
    use :: Galacticus_Error                    , only : Galacticus_Error_Report
    use :: Numerical_Constants_Astronomical    , only : megaParsec
    use :: Numerical_Constants_Prefixes        , only : centi
    implicit none
    class           (radiativeTransferMatterAtomic          ), intent(inout) :: self
    type            (radiativeTransferPropertiesMatterAtomic), intent(inout) :: properties
    double precision                                                         :: densityNumberElectrons
    integer                                                                  :: i                     , j

    densityNumberElectrons=0.0d0
    do i=1,self%countElements
       do j=1,self%elementAtomicNumbers(i)
          densityNumberElectrons=+                       densityNumberElectrons     &
               &                 +properties%elements(i)%densityNumber              &
               &                 *properties%elements(i)%ionizationStateFraction(j) &
               &                 *dble                                          (j)
       end do
    end do
    if (self%indexHydrogen > 0) then
       atomicRecombinationRateHydrogen=+                                                                 densityNumberElectrons                                                       &
            &                          *properties%elements                         (self%indexHydrogen)%densityNumber                                                                &
            &                          *properties%elements                         (self%indexHydrogen)%ionizationStateFraction(  1                                                ) &
            &                          *self      %atomicRecombinationRateRadiative_                    %rate                   (1,1,properties%temperature,level=recombinationCaseB) &
            &                          *properties%volume                                                                                                                             &
            &                          *(                                                                                                                                             &
            &                            +megaParsec                                                                                                                                  &
            &                            /centi                                                                                                                                       &
            &                           )**3
    else
       atomicRecombinationRateHydrogen=+0.0d0
       call Galacticus_Error_Report('hydrogren is not present'//{introspection:location})
    end if
    return
  end function atomicRecombinationRateHydrogen
